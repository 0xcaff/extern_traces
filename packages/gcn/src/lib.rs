#![feature(cursor_remaining)]

mod instructions;
mod reader;
mod resources;
pub mod test_utils;

pub use instructions::*;
pub use resources::*;

#[cfg(test)]
mod tests {
    use crate::test_utils::GCNInstructionStream;

    #[test]
    fn test_cube_vertex_shader() {
        let data: [u8; 0x78] = [
            0x00, 0x21, 0x80, 0xBE, 0x00, 0x07, 0x80, 0xC0, 0x7F, 0xC0, 0x8C, 0xBF, 0x08, 0x01,
            0x82, 0xC2, 0x0C, 0x01, 0x84, 0xC2, 0x04, 0x01, 0x86, 0xC2, 0x00, 0x01, 0x80, 0xC2,
            0x71, 0x00, 0x8C, 0xBF, 0x04, 0x0C, 0x0E, 0x10, 0x05, 0x0C, 0x00, 0x10, 0x06, 0x0C,
            0x02, 0x10, 0x07, 0x0C, 0x0C, 0x10, 0x08, 0x0E, 0x0E, 0x06, 0x09, 0x00, 0x00, 0x06,
            0x0A, 0x02, 0x02, 0x06, 0x0B, 0x0C, 0x0C, 0x06, 0x0C, 0x0A, 0x0E, 0x3E, 0x0D, 0x0A,
            0x00, 0x3E, 0x0E, 0x0A, 0x02, 0x3E, 0x0F, 0x0A, 0x0C, 0x3E, 0x00, 0x08, 0x0E, 0x3E,
            0x01, 0x08, 0x00, 0x3E, 0x02, 0x08, 0x02, 0x3E, 0x03, 0x08, 0x0C, 0x3E, 0xCF, 0x08,
            0x00, 0xF8, 0x07, 0x00, 0x01, 0x06, 0x70, 0x3F, 0x8C, 0xBF, 0x03, 0x02, 0x00, 0xF8,
            0x08, 0x09, 0x80, 0x80, 0x00, 0x00, 0x81, 0xBF,
        ];

        //   s_swappc_b64  s[0:1], s[0:1]
        //   s_load_dwordx4 s[0:3], s[6:7], 0x00
        //   s_waitcnt     0xc07f
        //   s_buffer_load_dwordx4 s[4:7], s[0:3], 0x08
        //   s_buffer_load_dwordx4 s[8:11], s[0:3], 0x0c
        //   s_buffer_load_dwordx4 s[12:15], s[0:3], 0x04
        //   s_buffer_load_dwordx4 s[0:3], s[0:3], 0x00
        //   s_waitcnt     vmcnt(1) & lgkmcnt(0)
        //   v_mul_f32     v7, s4, v6
        //   v_mul_f32     v0, s5, v6
        //   v_mul_f32     v1, s6, v6
        //   v_mul_f32     v6, s7, v6
        //   v_add_f32     v7, s8, v7
        //   v_add_f32     v0, s9, v0
        //   v_add_f32     v1, s10, v1
        //   v_add_f32     v6, s11, v6
        //   v_mac_f32     v7, s12, v5
        //   v_mac_f32     v0, s13, v5
        //   v_mac_f32     v1, s14, v5
        //   v_mac_f32     v6, s15, v5
        //   v_mac_f32     v7, s0, v4
        //   v_mac_f32     v0, s1, v4
        //   v_mac_f32     v1, s2, v4
        //   v_mac_f32     v6, s3, v4
        //   exp           pos0, v7, v0, v1, v6 done
        //   s_waitcnt     0x3f70
        //   exp           param0, v8, v9, off, off
        //   s_endpgm

        let shader = GCNInstructionStream::new(&data).unwrap();
        insta::assert_snapshot!(shader.debug());
        insta::assert_snapshot!(shader.displayed());
    }

    #[test]
    fn test_cube_fragment_shader() {
        let data: [u8; 0x4C] = [
            0x7E, 0x0A, 0xFE, 0xBE, 0x00, 0x01, 0xC4, 0xC0, 0x08, 0x01, 0x80, 0xC0, 0x04, 0x03,
            0xFC, 0xBE, 0x00, 0x00, 0x08, 0xC8, 0x01, 0x00, 0x09, 0xC8, 0x00, 0x01, 0x00, 0xC8,
            0x01, 0x01, 0x01, 0xC8, 0x00, 0x03, 0x06, 0x7E, 0x7F, 0xC0, 0x8C, 0xBF, 0x00, 0x07,
            0x80, 0xF0, 0x02, 0x00, 0x02, 0x00, 0x70, 0x3F, 0x8C, 0xBF, 0x00, 0x03, 0x00, 0x5E,
            0x01, 0x00, 0x5E, 0xD2, 0x02, 0xE5, 0x01, 0x00, 0x0F, 0x1C, 0x00, 0xF8, 0x00, 0x01,
            0x80, 0x80, 0x00, 0x00, 0x81, 0xBF,
        ];

        //   s_wqm_b64     exec, exec
        //   s_load_dwordx8 s[8:15], s[0:1], 0x00
        //   s_load_dwordx4 s[0:3], s[0:1], 0x08
        //   s_mov_b32     m0, s4
        //   v_interp_p1_f32 v2, v0, attr0.x
        //   v_interp_p2_f32 v2, v1, attr0.x
        //   v_interp_p1_f32 v0, v0, attr0.y
        //   v_interp_p2_f32 v0, v1, attr0.y
        //   v_mov_b32     v3, v0
        //   s_waitcnt     0xc07f
        //   image_sample  v[0:2], v[2:3], s[8:15], s[0:3] dmask:0x7
        //   s_waitcnt     0x3f70
        //   v_cvt_pkrtz_f16_f32 v0, v0, v1
        //   v_cvt_pkrtz_f16_f32 v1, v2, 1.0
        //   exp           mrt_color0, v0, v1 compr vm done
        //   s_endpgm

        let shader = GCNInstructionStream::new(&data).unwrap();
        insta::assert_snapshot!(shader.debug());
        insta::assert_snapshot!(shader.displayed());
    }

    #[test]
    fn test_compute_shader() {
        // Compute shader from pm4::packet::tests::compute_and_graphics
        let data: [u8; 0x4C] = [
            0xFF, 0x03, 0xEB, 0xBE, 0x0D, 0x00, 0x00, 0x00, 0x0C, 0xC0, 0x6A, 0x93, 0x00, 0x09,
            0x06, 0xC2, 0x6A, 0x00, 0x00, 0x4A, 0x7F, 0x00, 0x8C, 0xBF, 0x0C, 0x00, 0xA8, 0x7D,
            0x0A, 0x00, 0x88, 0xBF, 0x01, 0x09, 0x04, 0xC2, 0x7F, 0x00, 0x8C, 0xBF, 0x08, 0x00,
            0x02, 0x36, 0x00, 0x20, 0x00, 0xE0, 0x01, 0x01, 0x00, 0x80, 0x00, 0x00, 0xA8, 0xD1,
            0x06, 0x00, 0x02, 0x00, 0x70, 0x0F, 0x8C, 0xBF, 0x00, 0x20, 0x10, 0xE0, 0x00, 0x01,
            0x01, 0x80, 0x00, 0x00, 0x81, 0xBF,
        ];

        let shader = GCNInstructionStream::new(&data).unwrap();
        insta::assert_snapshot!(shader.debug());
        insta::assert_snapshot!(shader.displayed());
    }

    #[test]
    fn test_clear_shader() {
        let data: [u8; 0x94] = [
            0x00, 0x03, 0x86, 0xC0, 0x04, 0x03, 0x88, 0xC0, 0x7F, 0x00, 0x8C, 0xBF, 0x00, 0x20, 0x0C, 0xE0,
            0x00, 0x04, 0x03, 0x80, 0x00, 0x20, 0x0C, 0xE0, 0x00, 0x08, 0x04, 0x80, 0x00, 0x00, 0x8C, 0xBF,
            0x00, 0x07, 0x80, 0xC0, 0x7F, 0xC0, 0x8C, 0xBF, 0x08, 0x01, 0x82, 0xC2, 0x0C, 0x01, 0x84, 0xC2,
            0x04, 0x01, 0x86, 0xC2, 0x00, 0x01, 0x80, 0xC2, 0x71, 0x00, 0x8C, 0xBF, 0x04, 0x0C, 0x0E, 0x10,
            0x05, 0x0C, 0x00, 0x10, 0x06, 0x0C, 0x02, 0x10, 0x07, 0x0C, 0x0C, 0x10, 0x08, 0x0E, 0x0E, 0x06,
            0x09, 0x00, 0x00, 0x06, 0x0A, 0x02, 0x02, 0x06, 0x0B, 0x0C, 0x0C, 0x06, 0x0C, 0x0A, 0x0E, 0x3E,
            0x0D, 0x0A, 0x00, 0x3E, 0x0E, 0x0A, 0x02, 0x3E, 0x0F, 0x0A, 0x0C, 0x3E, 0x00, 0x08, 0x0E, 0x3E,
            0x01, 0x08, 0x00, 0x3E, 0x02, 0x08, 0x02, 0x3E, 0x03, 0x08, 0x0C, 0x3E, 0xCF, 0x08, 0x00, 0xF8,
            0x07, 0x00, 0x01, 0x06, 0x70, 0x3F, 0x8C, 0xBF, 0x03, 0x02, 0x00, 0xF8, 0x08, 0x09, 0x80, 0x80,
            0x00, 0x00, 0x81, 0xBF,
        ];

        let shader = GCNInstructionStream::new(&data).unwrap();
        insta::assert_snapshot!(shader.debug());
        insta::assert_snapshot!(shader.displayed());
    }
}
